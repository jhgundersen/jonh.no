<!doctype html>

<html>

<head>
	<title>jonh.no</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
	<style>
		html {
			height: -webkit-fill-available;
		}

		body,
		html,
		p {
			margin: 0;
			padding: 0;
			font-family: 'Orbitron', monospace;
		}

		body {
			background-color: black;
			width: 100%;
			min-height: 100vh;
			min-height: -webkit-fill-available;
			display: flex;
			flex-direction: column;

			background-image: url('frontpage-hd.png');
			background-size: cover;
			background-position: center;
			background-repeat: no-repeat;
		}


		canvas {
			background: transparent;
		}

		#info {
			display: flex;
			flex-direction: column;
			gap: 20px;
			font-weight: 700;
			font-size: 18px;
		}

		.box {
			border: 1px solid #555;
			border-radius: 10px;
		}

		.tetris {
			position: absolute;
			top: 200px;
			right: 200px;
			display: flex;
			gap: 20px;
			align-items: flex-start;
			justify-content: center;
			padding-bottom: 100px;
			padding-left: 100px;
		}

		.content {
			display: flex;
			padding: 10px;
			align-items: baseline;
		}

		.score {
			background-color: white;
			opacity: 0.6;
			padding: 10px;
		}

		.score-text {
			opacity: 1;
		}

		.small {
			font-size: 0.8em;
		}
	</style>

<body>

	<div style="flex: 1;"></div>
	<div class="content">
		<div style="flex: 1"></div>
		<audio style="margin: 20px;" controls loop src="/jonh.no.mp3"></audio>
	</div>

	<div class="tetris">
		<canvas id="tetris" class="box" width="240" height="400"></canvas>
		<div id="info">
			<div class="score box">
				<div class="score-text">
					<div>Score: <span id="score">0</span></div>
					<div class="small">Last: <span id="lastScore">0</span></div>
					<div class="small">High: <span id="highScore">0</span></div>
				</div>
			</div>
			<canvas id="next" class="box" width="80" height="80"></canvas>
		</div>
	</div>

	<script>
		const canvas = document.getElementById('tetris');
		const context = canvas.getContext('2d');
		context.scale(20, 20);

		const nextCanvas = document.getElementById('next');
		const nextContext = nextCanvas.getContext('2d');
		nextContext.scale(20, 20);

		const scoreDisplay = document.getElementById('score');
		const lastScoreDisplay = document.getElementById('lastScore');
		const highScoreDisplay = document.getElementById('highScore');

		let score = 0;
		let lastScore = 0;
		let highScore = 0;

		// Load scores from localStorage
		function loadScores() {
			lastScore = parseInt(localStorage.getItem('tetrisLastScore')) || 0;
			highScore = parseInt(localStorage.getItem('tetrisHighScore')) || 0;
			updateScoreDisplay();
		}

		// Save scores to localStorage
		function saveScores() {
			localStorage.setItem('tetrisLastScore', lastScore);
			localStorage.setItem('tetrisHighScore', highScore);
		}

		function createMatrix(w, h) {
			const matrix = [];
			while (h--) {
				matrix.push(new Array(w).fill(0));
			}
			return matrix;
		}

		function createPiece(type) {
			if (type === 'T') {
				return [
					[0, 0, 0],
					[1, 1, 1],
					[0, 1, 0],
				];
			} else if (type === 'O') {
				return [
					[2, 2],
					[2, 2],
				];
			} else if (type === 'L') {
				return [
					[0, 3, 0],
					[0, 3, 0],
					[0, 3, 3],
				];
			} else if (type === 'J') {
				return [
					[0, 4, 0],
					[0, 4, 0],
					[4, 4, 0],
				];
			} else if (type === 'I') {
				return [
					[0, 5, 0, 0],
					[0, 5, 0, 0],
					[0, 5, 0, 0],
					[0, 5, 0, 0],
				];
			} else if (type === 'S') {
				return [
					[0, 6, 6],
					[6, 6, 0],
					[0, 0, 0],
				];
			} else if (type === 'Z') {
				return [
					[7, 7, 0],
					[0, 7, 7],
					[0, 0, 0],
				];
			} else if (type === 'X') { // Cross/Plus shape
				return [
					[0, 8, 0],
					[8, 8, 8],
					[0, 8, 0],
				];
			} else if (type === 'U') { // U-shape
				return [
					[9, 0, 9],
					[9, 9, 9],
					[0, 0, 0],
				];
			} else if (type === 'P') { // Small L
				return [
					[10, 10],
					[10, 0],
				];
			} else if (type === 'D') { // Diamond/dot
				return [
					[11],
				];
			}
		}

		function drawMatrix(ctx, matrix, offset) {
			matrix.forEach((row, y) => {
				row.forEach((value, x) => {
					if (value !== 0) {
						ctx.fillStyle = colors[value];
						ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
					}
				});
			});
		}

		function draw() {
			context.clearRect(0, 0, canvas.width, canvas.height);
			context.fillStyle = "rgba(0, 0, 0, 0.6)";
			context.fillRect(0, 0, canvas.width, canvas.height);
			drawMatrix(context, arena, { x: 0, y: 0 });
			drawMatrix(context, player.matrix, player.pos);
		}

		function drawNext() {
			nextContext.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
			nextContext.fillStyle = "rgba(0, 0, 0, 0.6)";
			nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

			// Find the bounding box of the actual piece (non-zero cells)
			let minX = next.matrix[0].length, maxX = -1;
			let minY = next.matrix.length, maxY = -1;

			for (let y = 0; y < next.matrix.length; y++) {
				for (let x = 0; x < next.matrix[y].length; x++) {
					if (next.matrix[y][x] !== 0) {
						minX = Math.min(minX, x);
						maxX = Math.max(maxX, x);
						minY = Math.min(minY, y);
						maxY = Math.max(maxY, y);
					}
				}
			}

			// Calculate actual piece dimensions
			const pieceWidth = maxX - minX + 1;
			const pieceHeight = maxY - minY + 1;

			// Center the piece in the 4x4 preview area
			const offsetX = (4 - pieceWidth) / 2 - minX;
			const offsetY = (4 - pieceHeight) / 2 - minY;

			drawMatrix(nextContext, next.matrix, { x: offsetX, y: offsetY });
		}

		function merge(arena, player) {
			player.matrix.forEach((row, y) => {
				row.forEach((value, x) => {
					if (value !== 0) {
						arena[y + player.pos.y][x + player.pos.x] = value;
					}
				});
			});
		}

		function collide(arena, player) {
			const [m, o] = [player.matrix, player.pos];
			for (let y = 0; y < m.length; ++y) {
				for (let x = 0; x < m[y].length; ++x) {
					if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
						return true;
					}
				}
			}
			return false;
		}

		function playerDrop() {
			player.pos.y++;
			if (collide(arena, player)) {
				player.pos.y--;
				merge(arena, player);
				playerReset();
				arenaSweep();
			}
			dropCounter = 0;
		}

		function playerHardDrop() {
			while (!collide(arena, player)) {
				player.pos.y++;
			}
			player.pos.y--;
			merge(arena, player);
			playerReset();
			arenaSweep();
			dropCounter = 0;
		}

		function playerMove(dir) {
			player.pos.x += dir;
			if (collide(arena, player)) {
				player.pos.x -= dir;
			}
		}

		function playerReset() {
			player.matrix = next.matrix;
			next.matrix = createPiece(randomPiece());
			drawNext();
			player.pos.y = 0;
			player.pos.x = Math.floor(arena[0].length / 2) - Math.floor(player.matrix[0].length / 2);
			if (collide(arena, player)) {
				// Game over - save current score as last score
				lastScore = score;
				saveScores();

				arena.forEach(row => row.fill(0));
				score = 0;
				updateScoreDisplay();
				console.log("Game over. Score: " + lastScore);
			}
		}

		function playerRotate(dir) {
			const pos = player.pos.x;
			let offset = 1;
			rotate(player.matrix, dir);
			while (collide(arena, player)) {
				player.pos.x += offset;
				offset = -(offset + (offset > 0 ? 1 : -1));
				if (offset > player.matrix[0].length) {
					rotate(player.matrix, -dir);
					player.pos.x = pos;
					return;
				}
			}
		}

		function rotate(matrix, dir) {
			for (let y = 0; y < matrix.length; ++y) {
				for (let x = 0; x < y; ++x) {
					[matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
				}
			}
			if (dir > 0) {
				matrix.forEach(row => row.reverse());
			} else {
				matrix.reverse();
			}
		}

		function arenaSweep() {
			let rowCount = 1;
			outer: for (let y = arena.length - 1; y >= 0; --y) {
				for (let x = 0; x < arena[y].length; ++x) {
					if (arena[y][x] === 0) {
						continue outer;
					}
				}
				const row = arena.splice(y, 1)[0].fill(0);
				arena.unshift(row);
				++y;
				score += rowCount * 10;
				rowCount *= 2;
			}
			updateScore();
		}

		function updateScore() {
			scoreDisplay.innerText = score;
			if (score > highScore) {
				highScore = score;
				highScoreDisplay.innerText = highScore;
			}
		}

		function updateScoreDisplay() {
			scoreDisplay.innerText = score;
			lastScoreDisplay.innerText = lastScore;
			highScoreDisplay.innerText = highScore;
		}

		function randomPiece() {
			// Weighted probability system
			// Higher numbers = more common pieces
			const pieceWeights = {
				'T': 15,  // Standard pieces - common
				'O': 15,
				'L': 15,
				'J': 15,
				'I': 12,  // I-piece slightly less common
				'S': 12,
				'Z': 12,
				'X': 8,   // Special pieces - less common
				'U': 6,
				'P': 4,   // Rare pieces
				'D': 1    // Ultra rare single dot
			};

			// Create weighted array
			const weightedPieces = [];
			for (const [piece, weight] of Object.entries(pieceWeights)) {
				for (let i = 0; i < weight; i++) {
					weightedPieces.push(piece);
				}
			}

			return weightedPieces[Math.floor(Math.random() * weightedPieces.length)];
		}

		const colors = [
			null,
			'#FF0D72', // T - Pink
			'#0DC2FF', // O - Cyan
			'#0DFF72', // L - Green
			'#F538FF', // J - Purple
			'#FF8E0D', // I - Orange
			'#FFE138', // S - Yellow
			'#3877FF', // Z - Blue
			'#FF6B6B', // X - Red
			'#4ECDC4', // U - Teal
			'#45B7D1', // P - Light Blue
			'#FFA07A', // D - Light Salmon
			'#98D8C8', // W - Mint
		];

		const arena = createMatrix(12, 20);

		const player = {
			pos: { x: 0, y: 0 },
			matrix: null,
		};

		const next = {
			matrix: createPiece(randomPiece()),
		};

		let dropCounter = 0;
		let dropInterval = 1000;

		let lastTime = 0;
		function update(time = 0) {
			const deltaTime = time - lastTime;
			lastTime = time;

			dropCounter += deltaTime;
			if (dropCounter > dropInterval) {
				playerDrop();
			}

			draw();
			requestAnimationFrame(update);
		}

		document.addEventListener('keydown', event => {
			if (event.key === 'ArrowLeft') {
				playerMove(-1);
			} else if (event.key === 'ArrowRight') {
				playerMove(1);
			} else if (event.key === 'ArrowDown') {
				playerDrop();
			} else if (event.key === 'ArrowUp') {
				playerRotate(1);
			} else if (event.code === 'Space') {
				playerHardDrop();
			}
		});

		playerReset();
		loadScores();
		update();
		drawNext();
	</script>
</body>

</html>