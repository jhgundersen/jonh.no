<!doctype html>

<html>

<head>
	<title>jonh.no</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">

	<style>
		html {
			height: -webkit-fill-available;
		}

		body,
		html,
		p {
			margin: 0;
			padding: 0;
			font-family: 'Orbitron', monospace;
		}

		body {
			background-color: black;
			width: 100%;
			min-height: 100vh;
			min-height: -webkit-fill-available;
			display: flex;
			flex-direction: column;

			background-image: url('frontpage-hd.png');
			background-size: cover;
			background-position: center;
			background-repeat: no-repeat;
		}


		canvas {
			background: transparent;
			border: 2px solid #555;
		}

		#info {
			display: flex;
			flex-direction: column;
			gap: 20px;
		}

		#next {
			background: transparent;
			border: 2px solid #555;
		}

		.tetris {
			display: flex;
			flex: 1;
			gap: 20px;
			align-items: top;
			justify-content: center;
			transform: translateY(-20vh) translateX(20vh);
		}

		.content {
			display: flex;
			padding: 10px;
			align-items: baseline;
		}

		.score {
			background-color: white;
			opacity: 0.6;
			border: 2px solid #555;
			padding: 10px;
		}

		.score-text {
			opacity: 1;
		}
	</style>

<body>

	<div style="flex: 1;"></div>
	<div class="content">
		<div class="tetris">
			<canvas id="tetris" width="240" height="400"></canvas>
			<div id="info">
				<div class="score">
					<div class="score-text">Score: <span id="score">0</span></div>
				</div>
				<canvas id="next" width="80" height="80"></canvas>
			</div>
		</div>
		<audio style="margin: 20px;" controls loop src="/jonh.no.mp3"></audio>
	</div>

	<script>
		const canvas = document.getElementById('tetris');
		const context = canvas.getContext('2d');
		context.scale(20, 20);

		const nextCanvas = document.getElementById('next');
		const nextContext = nextCanvas.getContext('2d');
		nextContext.scale(20, 20);

		const scoreDisplay = document.getElementById('score');

		let score = 0;

		function createMatrix(w, h) {
			const matrix = [];
			while (h--) {
				matrix.push(new Array(w).fill(0));
			}
			return matrix;
		}

		function createPiece(type) {
			if (type === 'T') {
				return [
					[0, 0, 0],
					[1, 1, 1],
					[0, 1, 0],
				];
			} else if (type === 'O') {
				return [
					[2, 2],
					[2, 2],
				];
			} else if (type === 'L') {
				return [
					[0, 3, 0],
					[0, 3, 0],
					[0, 3, 3],
				];
			} else if (type === 'J') {
				return [
					[0, 4, 0],
					[0, 4, 0],
					[4, 4, 0],
				];
			} else if (type === 'I') {
				return [
					[0, 5, 0, 0],
					[0, 5, 0, 0],
					[0, 5, 0, 0],
					[0, 5, 0, 0],
				];
			} else if (type === 'S') {
				return [
					[0, 6, 6],
					[6, 6, 0],
					[0, 0, 0],
				];
			} else if (type === 'Z') {
				return [
					[7, 7, 0],
					[0, 7, 7],
					[0, 0, 0],
				];
			}
		}

		function drawMatrix(ctx, matrix, offset) {
			matrix.forEach((row, y) => {
				row.forEach((value, x) => {
					if (value !== 0) {
						ctx.fillStyle = colors[value];
						ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
					}
				});
			});
		}

		function draw() {
			context.clearRect(0, 0, canvas.width, canvas.height);
			context.fillStyle = "rgba(0, 0, 0, 0.6)";
			context.fillRect(0, 0, canvas.width, canvas.height);
			drawMatrix(context, arena, { x: 0, y: 0 });
			drawMatrix(context, player.matrix, player.pos);
		}

		function drawNext() {
			nextContext.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
			nextContext.fillStyle = "rgba(0, 0, 0, 0.6)";
			nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
			drawMatrix(nextContext, next.matrix, { x: 1, y: 1 });
		}

		function merge(arena, player) {
			player.matrix.forEach((row, y) => {
				row.forEach((value, x) => {
					if (value !== 0) {
						arena[y + player.pos.y][x + player.pos.x] = value;
					}
				});
			});
		}

		function collide(arena, player) {
			const [m, o] = [player.matrix, player.pos];
			for (let y = 0; y < m.length; ++y) {
				for (let x = 0; x < m[y].length; ++x) {
					if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
						return true;
					}
				}
			}
			return false;
		}

		function playerDrop() {
			player.pos.y++;
			if (collide(arena, player)) {
				player.pos.y--;
				merge(arena, player);
				playerReset();
				arenaSweep();
			}
			dropCounter = 0;
		}

		function playerHardDrop() {
			while (!collide(arena, player)) {
				player.pos.y++;
			}
			player.pos.y--;
			merge(arena, player);
			playerReset();
			arenaSweep();
			dropCounter = 0;
		}

		function playerMove(dir) {
			player.pos.x += dir;
			if (collide(arena, player)) {
				player.pos.x -= dir;
			}
		}

		function playerReset() {
			player.matrix = next.matrix;
			next.matrix = createPiece(randomPiece());
			drawNext();
			player.pos.y = 0;
			player.pos.x = Math.floor(arena[0].length / 2) - Math.floor(player.matrix[0].length / 2);
			if (collide(arena, player)) {
				arena.forEach(row => row.fill(0));
				score = 0;
				updateScore();
				console.log("Game over. Score reset.");
			}
		}

		function playerRotate(dir) {
			const pos = player.pos.x;
			let offset = 1;
			rotate(player.matrix, dir);
			while (collide(arena, player)) {
				player.pos.x += offset;
				offset = -(offset + (offset > 0 ? 1 : -1));
				if (offset > player.matrix[0].length) {
					rotate(player.matrix, -dir);
					player.pos.x = pos;
					return;
				}
			}
		}

		function rotate(matrix, dir) {
			for (let y = 0; y < matrix.length; ++y) {
				for (let x = 0; x < y; ++x) {
					[matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
				}
			}
			if (dir > 0) {
				matrix.forEach(row => row.reverse());
			} else {
				matrix.reverse();
			}
		}

		function arenaSweep() {
			let rowCount = 1;
			outer: for (let y = arena.length - 1; y >= 0; --y) {
				for (let x = 0; x < arena[y].length; ++x) {
					if (arena[y][x] === 0) {
						continue outer;
					}
				}
				const row = arena.splice(y, 1)[0].fill(0);
				arena.unshift(row);
				++y;
				score += rowCount * 10;
				rowCount *= 2;
			}
			updateScore();
		}

		function updateScore() {
			scoreDisplay.innerText = score;
		}

		function randomPiece() {
			const pieces = 'TJLOSZI';
			return pieces[Math.floor(Math.random() * pieces.length)];
		}

		const colors = [
			null,
			'#FF0D72',
			'#0DC2FF',
			'#0DFF72',
			'#F538FF',
			'#FF8E0D',
			'#FFE138',
			'#3877FF',
		];

		const arena = createMatrix(12, 20);

		const player = {
			pos: { x: 0, y: 0 },
			matrix: null,
		};

		const next = {
			matrix: createPiece(randomPiece()),
		};

		let dropCounter = 0;
		let dropInterval = 1000;

		let lastTime = 0;
		function update(time = 0) {
			const deltaTime = time - lastTime;
			lastTime = time;

			dropCounter += deltaTime;
			if (dropCounter > dropInterval) {
				playerDrop();
			}

			draw();
			requestAnimationFrame(update);
		}

		document.addEventListener('keydown', event => {
			if (event.key === 'ArrowLeft') {
				playerMove(-1);
			} else if (event.key === 'ArrowRight') {
				playerMove(1);
			} else if (event.key === 'ArrowDown') {
				playerDrop();
			} else if (event.key === 'ArrowUp') {
				playerRotate(1);
			} else if (event.code === 'Space') {
				playerHardDrop();
			}
		});

		playerReset();
		update();
		updateScore();
		drawNext();
	</script>
</body>

</html>